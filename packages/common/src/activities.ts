import { Context, Info } from '@temporalio/activity';
import { ActivityExecuteInput, ActivityInboundCallsInterceptor, Next } from '@temporalio/worker';
import { Logger } from 'winston';

/** An Activity Context with an attached logger */
export interface ContextWithLogger extends Context {
  logger: Logger;
}

/** Get the current Activity context with an attached logger */
export function getContext(): ContextWithLogger {
  return Context.current() as ContextWithLogger;
}

/** Logs Activity executions and their duration */
export class ActivityInboundLogInterceptor implements ActivityInboundCallsInterceptor {
  public readonly logger: Logger;
  public readonly info: Info;

  constructor(ctx: Context, logger: Logger) {
    this.logger = logger.child({
      activity: ctx.info,
    });

    this.info = ctx.info;

    // Set a logger instance on the current Activity Context to provide
    // contextual logging information to each log entry generated by the Activity.
    (ctx as ContextWithLogger).logger = logger;
  }

  async execute(input: ActivityExecuteInput, next: Next<ActivityInboundCallsInterceptor, 'execute'>): Promise<unknown> {
    let error: unknown = undefined;
    const startTime = process.hrtime.bigint();
    try {
      return await next(input);
    } catch (err: unknown) {
      error = err;
      throw err;
    } finally {
      const durationNanos = process.hrtime.bigint() - startTime;
      const durationMs = Number(durationNanos / 1_000_000n);
      if (error) {
        // this.logger.error('Failed', { error, durationMs });
        this.logger.error(
          `[${this.info.workflowType}] [${this.info.workflowExecution.workflowId}] [${this.info.activityId}]: Error ${durationMs}ms ${error}`,
        );
      } else {
        this.logger.debug(
          `[${this.info.workflowType}] [${this.info.workflowExecution.workflowId}] [${this.info.activityId}]: Completed ${durationMs}ms`,
        );
      }
    }
  }
}
